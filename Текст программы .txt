import os  # Системная библиотека для указания деректив, создания папок, движение по папками
import re
import time  # Библиотека для работы со временем
import requests  # библиотека для создания requests запросов (HTML)
import datetime  # Библиотека для получения даты файлов
import pymorphy2  # Библиотека для создания леммы слова
import unicodedata  # Библиотека для нормализации текста
import pandas as pd  # Библиотека для создания таблиц и работы с ними
import urllib.request  # Библиотека для чтения HTML
from lxml import html
from nltk import bigrams  # Библиотекадял создания биграмм
from bs4 import BeautifulSoup  # Библиотека для сбора информации из интернета
from operator import itemgetter  # Библиотека используется для работы функции резюме
from collections import Counter  # Библиотека для расчета ключевых слов
from readability import Document  # Библиотека для работы с HTML файлами
morph = pymorphy2.MorphAnalyzer()  # Подключение морфологического анализа
#
# --------------------- Модуль библиотек для работы с окнами приложения ----------------------------
#
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QThread, pyqtSignal, QObject, pyqtSlot
#
#
#
# ---------- Работа с прокси (Получение, проверка и отправка -----------------------------------------------------------
# Поиск подходящего прокси с timeout в 50ms (ограничение для экономии времени)
# Загручка всех прокси проходящих время


def get_proxy_list():  # Получаем список прокси для доступа на "закрытые сайты"
    proxy_url = 'https://api.proxyscrape.com/?request=getproxies&proxytype=http&timeout=50&country=all&ssl=all&anonymity=all'
    r = requests.get(proxy_url)
    proxy_list = r.text.split()
    return proxy_list


def check_proxy(px, check_url):  # Проверка прокси на рабооспособность
    try:
        requests.get(check_url, proxies=px, timeout=55)
    except Exception:
        return False
    return True


def right_proxy(try_url):  # Выявление нужного прокси
    alive_proxy_list = {}

    for procxy in get_proxy_list():
        proxies = {
            "http": "http://" + procxy,
            "https": "https://" + procxy
        }
        if check_proxy(proxies, try_url):
            alive_proxy_list = proxies
            break
    return alive_proxy_list


# ---------- Модуль получения информации о ссылке (Название, текст и код доступа) --------------------------------------
def access(url, count_errors):  # Доступ к сайтам и сбор информации
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 OPR/71.0.3770.148'}

    try:  # Поробуем получить доступ без прокси
        r = requests.get(url, headers=headers)
    except requests.exceptions.TooManyRedirects:  # Если ошибка TooManyRedirects пропускаем сайт
        return 'EN', '', '404 Error', count_errors
    except requests.exceptions.ConnectionError:  # Пробуем получить доступ с прокси
        r = procxy_request(url, headers)
    if r == 'No right proxcies':  # Нет подходящих прокси для доступа к сайту
        count_errors += 1
        return f'No right proxcies {count_errors}', '', '', count_errors
    elif r.status_code == 200:  # Если был получен доступ к сайту, выполнить code_200
        html = code_200(r, url)
        if html == 'file':  # Тригер для сценария file
            return 'file', r.content, url[-4:], count_errors
        if html == 'ED':  # Тригер для сценария когда пустой результат
            return 'EN', 'пустой сайт', 200, count_errors
        text_name = get_text_name(html)  # Получение текста и названия
        return text_name[0], text_name[1], 200, count_errors
    elif r.status_code != 404:  # Попытка получить доступ с прокси ещё раз
        rp = procxy_request(url, headers)
        if rp == 'No right proxcies':  # Нет подходящих прокси для доступа к сайту
            count_errors += 1
            return f'No right proxcies {count_errors}', '', '', count_errors
        elif rp.status_code == 200:  # Если был получен доступ к сайту, выполнить code_200
            html = code_200(r, url)
            if html == 'file':  # Тригер для сценария file
                return 'file', r.content, url[-4:], count_errors
            if html == 'ED':  # Тригер для сценария когда пустой результат
                return 'EN', 'пустой сайт', 200, count_errors
            text_name = get_text_name(html)  # Получение текста и названия
            return text_name[0], text_name[1], 200, count_errors
        else:  # Получить доступ не удалось ошибка ХХХ
            count_errors += 1
            return 'EN', '', f'{rp.status_code} Error', count_errors
    else:  # Получить доступ не удалось ошибка 404
        count_errors += 1
        return 'EN', '', '404 Error', count_errors


# ----------- Модуль работы с текстами HTML ----------------------------------------------------------------------------
def get_text_name(markup):  # Получение текста и названия
    try:  # Попытка получить разметку HTML и вытащить текста
        doc = Document(markup)
        read_article = doc.summary()
        text = BeautifulSoup(read_article, 'html.parser').get_text()
    except Exception:  # Если неуспешно выходим из функции
        return 'Невозможно получить текст', ''

    html_clear = clean(text)  # Очистка текста от мусора
    title = doc.short_title()[:10]  # Получение title
    if title is None or title == '' or title == ' ':  # Если title пустой, то пришем триггер
            title = 'EN'
    try:  # Попытка получение текста h1
        h1 = deletion(BeautifulSoup(read_article, 'html.parser').find('h1').text)
        if h1 is None or h1 == '' or h1 == ' ':  # Если h1 пустой, то пришем триггер
            h1 = ' h1'
        name = deletion(title + h1[:10])  # Очистка от знаков
    except Exception:  # Если неуспешно, то h1 == ' h1'
        name = deletion(title + ' h1')
    return name, html_clear  # Возвращаем Название и текст


# ---------- Сценарий при успешной попытки зайти на сайт ---------------------------------------------------------------
def code_200(responce, url):
    tf = is_site(responce)  # Проверка сайта на наличия тела
    charset = ''
    try:  # Попытка получить charset сайта для регулировки кодироки
        resource = urllib.request.urlopen(url)
        charset = resource.headers.get_content_charset()
    except Exception:  # Если не получилось, пропустить
        pass
    if tf == 'ED':  # Если на сайте нет текста HTML или его не получилось вытащить выходим
        return 'ED'
    if tf:  # Если получилось вытащить текст HTML
        if win1251(responce) or charset == 'windows-1251':  # При необходимости меняем кодировку
            responce.encoding = 'windows-1251'
            html = responce.text
        else:
            responce.encoding = 'utf8'
            html = responce.text
        return html  # Отправляем текст HTML
    elif url.endswith('.doc') or url.endswith('.pdf') or url.endswith('.xls'):
        return 'file'
    else:
        return 'ED'


# Запрос с прокси ещё раз
def procxy_request(url, headers):
    difficult_request = 'No right proxcies'
    check = 0
    chance = 0
    while check == 0 and chance < 4:

        try:
            proxcy = right_proxy(url)
            difficult_request = requests.get(url, proxies=proxcy, headers=headers, timeout=100)
            check = 1
        except Exception:
            chance += 1
            check = 0
    if chance >= 4:
        difficult_request = 'No right proxcies'
    return difficult_request


# ----------Вспомогательный модуль для загрузки информации из HTML------------------------------------------------------
# проверка на кодировку 1251
def win1251(req):
    stro = html.fromstring(req.content)
    if stro.xpath('//head/meta[@content="text/html; charset=windows-1251"]'):
        return True
    elif stro.xpath('//head/meta[@content="text/html; CHARSET=Windows-1251"]'):
        return True
    elif stro.xpath('//head/meta[@content="text-html; charset=windows-1251"]'):
        return True
    elif stro.xpath('//head/meta[@charset="Windows-1251"]'):
        return True
    elif stro.xpath('//head/meta[@content="text/html; charset=Windows-1251"]'):
        return True
    elif stro.xpath('//head/meta[@content="text/html; charset=win-1251"]'):
        return True
    else:
        return False


# Проверка на сайт или файл
def is_site(req):
    try:
        stro = html.fromstring(req.content)
    except Exception:
        return 'ED'
    if stro.xpath('//head'):
        return True
    else:
        return False


# ---- Модуль функций для очистки, подготовки текста, а также создания ключевых слов, биграмм и резюме -----------------
def clean(raw):  # Полная очистка
    regex1 = re.compile(r'[\n\r\t]')
    regex2 = re.compile(r'[�✖•¶✔|;—~○™°‼§▬&]')
    prepre_itog = regex1.sub(" ", raw)
    pre_itog = regex2.sub("", prepre_itog)
    itog = unicodedata.normalize("NFKD", pre_itog)
    return itog


def deletion(text):  # Очистка от знаков
    regex = re.compile(r'[\n\r\t.,;:•¶“”"‼§?○™°!▬()*—<>{}|~#$%&/]')
    stop_symbols = regex.sub("", text)
    return stop_symbols


def ohten_words(text):  # Частые слова по факту
    data = Counter(text).most_common(11)
    out = ''
    for w in data:
        out += w[0] + ' '
    return out


def digrams(text):  # Биграммы
    list_bigram = list(bigrams(text))
    data = Counter(list_bigram).most_common(10)

    out = ''
    for w in data:
        out += w[0][0] + ' ' + w[0][1] + '; '
    return out[:-2]


def lemma(listing):  # Выявление лемм слов
    out = []
    for word in listing:
        if len(word) > 3:
            p = morph.parse(word)[0]
            out.append(p.normal_form.lower())
    return out


# Анотация
# 1) Для каждого слова в тексте определяется его взвешенная масса
# 2) Для каждого предложения определяется его взвешенная масса (сумма весов слов для предложения)
# 3) Выводится 5 самых "тяжелых" предложений
def anotation(big_text, lemma_pool):

    all_text_by_sen = sentences1(big_text)

    lemma_1 = set(lemma_pool)
    puiry = Counter(lemma_pool)
    maxi = 0

    for i in puiry.items():
        if i[1] > maxi:
            maxi = i[1]

    weighted_frequencies = {}

    for word in lemma_1:
        if len(word) > 3:
            weighted_frequencies[word] = puiry[word] / maxi

    result = []

    for sen in all_text_by_sen:
        weight_of_sentence = 0
        for words in lemma(sen):
            if words in weighted_frequencies:
                weight_of_sentence += weighted_frequencies[words]
        result.append([' '.join(sen), weight_of_sentence])

    output = ''

    if len(all_text_by_sen) >= 10:
        for i in sorted(result, key=itemgetter(1), reverse=True)[:10]:
            output += i[0].capitalize() + '. '
    else:
        for i in sorted(result, key=itemgetter(1), reverse=True):
            output += i[0].capitalize() + '. '

    return output


def sentences1(article):  # Создания списка, хранящий слова в отдельных предложениях
    ending = re.compile(r'[!?]')
    s = []
    one_end = ending.sub('.', article)
    for sentence in one_end.split('. '):
        one = []
        for words in sentence.split():
            one.append(words.lower())
        s.append(one)
    return s


#
# ---------------------------------- Модуль обьявления всех окно приложения --------------------------------------------
#
# Начальное окно, в котором вводятся список сайтов и тип собираемой информации
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1141, 607)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("icons/лого.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        MainWindow.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 1, 2, 1, 1)
        self.frame = QtWidgets.QFrame(self.centralwidget)
        self.frame.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.frame)
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_3 = QtWidgets.QLabel(self.frame)
        self.label_3.setEnabled(True)
        self.label_3.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_3.setObjectName("label_3")
        self.verticalLayout.addWidget(self.label_3)
        self.checkBox_4 = QtWidgets.QCheckBox(self.frame)
        self.checkBox_4.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.checkBox_4.setObjectName("checkBox_4")
        self.verticalLayout.addWidget(self.checkBox_4)
        self.line = QtWidgets.QFrame(self.frame)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.verticalLayout.addWidget(self.line)
        self.checkBox = QtWidgets.QCheckBox(self.frame)
        self.checkBox.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.checkBox.setObjectName("checkBox")
        self.verticalLayout.addWidget(self.checkBox)
        self.checkBox_2 = QtWidgets.QCheckBox(self.frame)
        self.checkBox_2.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.checkBox_2.setObjectName("checkBox_2")
        self.verticalLayout.addWidget(self.checkBox_2)
        self.checkBox_3 = QtWidgets.QCheckBox(self.frame)
        self.checkBox_3.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.checkBox_3.setObjectName("checkBox_3")
        self.verticalLayout.addWidget(self.checkBox_3)
        self.gridLayout.addWidget(self.frame, 2, 3, 1, 2)
        self.toolButton = QtWidgets.QToolButton(self.centralwidget)
        self.toolButton.setCursor(QtGui.QCursor(QtCore.Qt.WhatsThisCursor))
        self.toolButton.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.toolButton.setObjectName("toolButton")
        self.gridLayout.addWidget(self.toolButton, 0, 4, 1, 1)
        self.plainTextEdit = QtWidgets.QPlainTextEdit(self.centralwidget)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.plainTextEdit.setFont(font)
        self.plainTextEdit.setAccessibleName("")
        self.plainTextEdit.setOverwriteMode(False)
        self.plainTextEdit.setObjectName("plainTextEdit")
        self.gridLayout.addWidget(self.plainTextEdit, 2, 2, 1, 1)
        self.label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 2, 1, 1)
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.pushButton.setFont(font)
        self.pushButton.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton.setObjectName("pushButton")
        self.gridLayout.addWidget(self.pushButton, 3, 2, 1, 1)
        self.plainTextEdit.raise_()
        self.label.raise_()
        self.toolButton.raise_()
        self.label_2.raise_()
        self.pushButton.raise_()
        self.frame.raise_()
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1141, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Парсинг.Начальное окно"))
        self.label_2.setText(_translate("MainWindow", "Для начала сканирования введите в окно интересующие вас ссылки, разделяя их новой строкой"))
        self.label_3.setText(_translate("MainWindow", "Выбор параметров\n"
" парсинга:"))
        self.checkBox_4.setText(_translate("MainWindow", "Всё"))
        self.checkBox.setText(_translate("MainWindow", "Ключевы слова"))
        self.checkBox_2.setText(_translate("MainWindow", "Биграммы"))
        self.checkBox_3.setText(_translate("MainWindow", "Резюме"))
        self.toolButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt;\">Короткая инструкция</span></p></body></html>"))
        self.toolButton.setWhatsThis(_translate("MainWindow", "<html><head/><body><p><br/></p></body></html>"))
        self.toolButton.setText(_translate("MainWindow", "Помощь"))
        self.plainTextEdit.setPlaceholderText(_translate("MainWindow", "https://darpa.com\nhttps://www.google.ru/.../..."))
        self.label.setText(_translate("MainWindow", "Добро пожаловать."))
        self.pushButton.setText(_translate("MainWindow", "Запустить"))  # #


# Вспомогательное окно, в котором обьясняется принцип работы приложения
class Ui_HelpWindow(object):
    def setupUi(self, HelpWindow):
        HelpWindow.setObjectName("HelpWindow")
        HelpWindow.setFixedSize(445, 262)
        HelpWindow.setFocusPolicy(QtCore.Qt.NoFocus)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("icons/лого.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        HelpWindow.setWindowIcon(icon)
        self.gridLayout = QtWidgets.QGridLayout(HelpWindow)
        self.gridLayout.setObjectName("gridLayout")
        self.textEdit = QtWidgets.QTextEdit(HelpWindow)
        self.textEdit.setMinimumSize(QtCore.QSize(445, 262))
        self.textEdit.setMaximumSize(QtCore.QSize(445, 262))
        self.textEdit.setMouseTracking(False)
        self.textEdit.setFocusPolicy(QtCore.Qt.NoFocus)
        self.textEdit.setObjectName("textEdit")
        self.gridLayout.addWidget(self.textEdit, 0, 0, 1, 1)

        self.retranslateUi(HelpWindow)
        QtCore.QMetaObject.connectSlotsByName(HelpWindow)

    def retranslateUi(self, HelpWindow):
        _translate = QtCore.QCoreApplication.translate
        HelpWindow.setWindowTitle(_translate("HelpWindow", "Парсинг.Окно помощи"))
        self.textEdit.setHtml(_translate("HelpWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12pt;\">     Данное приложение созданно для упращения сбора информации в интернете.</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12pt;\">     В стартовом окне нужно ввести необходимые пользователю ссылки, каждую из которых отделять новой строкой.</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12pt;\">     Стандартный парсинг включает в себя </span><span style=\" font-size:12pt; font-style:italic;\">Название</span><span style=\" font-size:12pt;\"> и содержание </span><span style=\" font-size:12pt; font-style:italic;\">Полного текста</span><span style=\" font-size:12pt;\"> ресурса. </span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12pt;\">     Однако пользователь способен получить также Ключевые слова, Биграммы и Резюме текста. Для этого  можно отметить интересующие опции в специальной области &quot;Выбор параметров парсинга:&quot;. Если необходимы все параметры отметьте &quot;Всё&quot;.</span></p></body></html>"))


# Окно прогресса, включающее  в себя брогресс бар и возможность прервать выполнения работы программы
class Ui_ProgressWindow(object):
    def setupUi(self, ProgressWindow):
        ProgressWindow.setObjectName("ProgressWindow")
        ProgressWindow.resize(957, 538)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("icons/лого.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        ProgressWindow.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(ProgressWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 1, 1, 1, 1)
        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar.setProperty("value", 24)
        self.progressBar.setObjectName("progressBar")
        self.gridLayout.addWidget(self.progressBar, 2, 1, 1, 1)
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setObjectName("pushButton_2")
        self.gridLayout.addWidget(self.pushButton_2, 5, 3, 1, 1)
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 3, 1, 1, 1)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.frame = QtWidgets.QFrame(self.centralwidget)
        self.frame.setStyleSheet("background-color: qlineargradient(spread:pad, x1:0.0738182, y1:0.131, x2:0.699, y2:0.698864, stop:0 rgba(92, 0, 169, 255), stop:1 rgba(22, 106, 255, 255));")
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout.addWidget(self.frame, 1, 2, 4, 2)
        ProgressWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(ProgressWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 957, 21))
        self.menubar.setObjectName("menubar")
        ProgressWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(ProgressWindow)
        self.statusbar.setObjectName("statusbar")
        ProgressWindow.setStatusBar(self.statusbar)

        self.retranslateUi(ProgressWindow)
        QtCore.QMetaObject.connectSlotsByName(ProgressWindow)

    def retranslateUi(self, ProgressWindow):
        _translate = QtCore.QCoreApplication.translate
        ProgressWindow.setWindowTitle(_translate("ProgressWindow", "Парсинг.Окно Анализа"))
        self.label.setText(_translate("ProgressWindow", "Идет аналз ресурсов.\n"
"Пожалуйста подождите..."))
        self.pushButton_2.setText(_translate("ProgressWindow", "Прервать"))
        self.label_2.setText(_translate("ProgressWindow", "Название процеса и ресурса"))


# Вспомогательное окно подтверждения выхода из программы
class Ui_WarningWindow(object):
    def setupUi(self, WarningWindow):
        WarningWindow.setObjectName("WarningWindow")
        WarningWindow.setFixedSize(393, 203)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("icons/лого.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        WarningWindow.setWindowIcon(icon)
        self.pushButton = QtWidgets.QPushButton(WarningWindow)
        self.pushButton.setGeometry(QtCore.QRect(80, 160, 75, 23))
        self.pushButton.setMaximumSize(QtCore.QSize(16777215, 16777214))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton.setFont(font)
        self.pushButton.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(WarningWindow)
        self.pushButton_2.setGeometry(QtCore.QRect(240, 160, 75, 23))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton_2.setObjectName("pushButton_2")
        self.textEdit = QtWidgets.QTextEdit(WarningWindow)
        self.textEdit.setGeometry(QtCore.QRect(10, 10, 371, 131))
        self.textEdit.setMouseTracking(False)
        self.textEdit.setFocusPolicy(QtCore.Qt.NoFocus)
        self.textEdit.setObjectName("textEdit")

        self.retranslateUi(WarningWindow)
        QtCore.QMetaObject.connectSlotsByName(WarningWindow)

    def retranslateUi(self, WarningWindow):
        _translate = QtCore.QCoreApplication.translate
        WarningWindow.setWindowTitle(_translate("WarningWindow", "Парсинг.Окно предупреждения"))
        self.pushButton.setText(_translate("WarningWindow", "Прервать"))
        self.pushButton_2.setText(_translate("WarningWindow", "Отмена"))
        self.textEdit.setHtml(_translate("WarningWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:14pt;\">Внимание!</span><span style=\" font-size:12pt;\"><br />Если прервать процес анализа, то весь прогресс будет сброшен без возможности сохранения.</span></p></body></html>"))


# Окно вывода результатом анализа и сохранения в Excel
class Ui_OutWindow(object):
    def setupUi(self, OutWindow):
        OutWindow.setObjectName("OutWindow")
        OutWindow.resize(1182, 890)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("icons/лого.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        OutWindow.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(OutWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton_2.setObjectName("pushButton_2")
        self.gridLayout.addWidget(self.pushButton_2, 3, 2, 1, 1)
        self.label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        self.gridLayout.addWidget(self.tableWidget, 1, 0, 1, 3)
        OutWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(OutWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1182, 21))
        self.menubar.setObjectName("menubar")
        OutWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(OutWindow)
        self.statusbar.setObjectName("statusbar")
        OutWindow.setStatusBar(self.statusbar)

        self.retranslateUi(OutWindow)
        QtCore.QMetaObject.connectSlotsByName(OutWindow)



    def retranslateUi(self, OutWindow):
        _translate = QtCore.QCoreApplication.translate
        OutWindow.setWindowTitle(_translate("OutWindow", "Парсинг.Рузельтат анализа"))
        self.pushButton_2.setText(_translate("OutWindow", "Экспорт в .csv"))
        self.label.setText(_translate("OutWindow", "Спасибо за ожидание.\n"
"Результаты анализа:"))


#
# ------------------------------ Модуль подключения окон приложения и работы с ними ------------------------------------
#
# Обьявление стартового окна
class Parsing(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self):
        super(Parsing, self).__init__()

        self.setupUi(self)

        check_info = [0, 0, 0]  # Хранение онформации о типе сбоираемой информации (Ключевые слова, Биграммы, Резюме)
        self.toolButton.clicked.connect(self.show_helpwindow)  # Вывод окна помощи при нажатии на кномпку
        self.pushButton.clicked.connect(lambda: self.check(check_info))  # Получение информации о выбраных чекбоксах
        self.pushButton.clicked.connect(lambda: self.show_progresswindow(check_info))  # Переход к окну прогресса при нажатии на кнопку
        self.checkBox_4.clicked.connect(self.all_checkBox)  # Выбор всех чекбоксов при нажатии на "Все"

    def show_helpwindow(self):  # Вывод окна помощи при нажатии на кномпку
        self.hw = SecondWindow()
        self.hw.show()

    def get_text(self):  # Получение списка введеных ссылок из окна
        return self.plainTextEdit.toPlainText().split('\n')

    def check(self, check_info):  # Получение информации о выбраных чекбоксах
        if self.checkBox.isChecked():
            check_info[0] = 1
        if self.checkBox_2.isChecked():
            check_info[1] = 1
        if self.checkBox_3.isChecked():
            check_info[2] = 1

    def all_checkBox(self):  # Выбор всех чекбоксов при нажатии на "Все"
        if self.checkBox_4.isChecked():
            self.checkBox.setChecked(True)
            self.checkBox_2.setChecked(True)
            self.checkBox_3.setChecked(True)
        else:
            self.checkBox.setChecked(False)
            self.checkBox_2.setChecked(False)
            self.checkBox_3.setChecked(False)

    def show_progresswindow(self, check_info):  # Переход к окну прогресса при нажатии на кнопку
        self.setVisible(False)
        parselist = self.get_text()
        self.pw = ProgressWindow(parselist, check_info)
        self.pw.show()


# Обьявление окна помощи
class SecondWindow(QtWidgets.QMainWindow, Ui_HelpWindow):
    def __init__(self, parent=None):
        super(SecondWindow, self).__init__(parent)

        self.setupUi(self)


# Обьявление окна прогресса
class ProgressWindow(QtWidgets.QMainWindow, Ui_ProgressWindow):
    def __init__(self, parselist, check_info, parent=None):
        super(ProgressWindow, self).__init__(parent)

        self.parselist = parselist  # Список ссылок

        for i in self.parselist:
            if not i.startswith('https://'):
                self.parselist.remove(i)

        self.check_info = check_info  # Список чекбоксов

        self.setupUi(self)

        # Установление минимума и максимума в прогрессбаре
        self.progressBar.setMinimum(0)
        self.progressBar.setMaximum(len(self.parselist) * (self.check_info.count(1) + 2))

        self.progressinfo = self.label_2  # Подключение к метке оповещения о процессе работы программы

        self.out = OutWindow()  # Подключение окна вывода

        # Подготовка таблицы для вывода анализа
        self.out.tableWidget.setColumnCount(self.check_info.count(1) + 2)
        self.out.tableWidget.setRowCount(len(self.parselist))
        self.out.tableWidget.verticalHeader().setDefaultSectionSize(1000)
        self.out.tableWidget.verticalHeader().setMinimumSectionSize(200)
        self.out.tableWidget.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.out.tableWidget.verticalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        self.out.tableWidget.setVerticalScrollMode(1)
        if self.check_info == [0, 0, 0]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Полный текст"])
        if self.check_info == [1, 0, 0]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Ключевые слова", "Полный текст"])
        if self.check_info == [0, 1, 0]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Биграммы", "Полный текст"])
        if self.check_info == [0, 0, 1]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Резюме", "Полный текст"])
        if self.check_info == [1, 1, 0]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Ключевые слова", "Биграммы", "Полный текст"])
        if self.check_info == [1, 0, 1]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Ключевые слова", "Резюме", "Полный текст"])
        if self.check_info == [0, 1, 1]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Биграммы", "Резюме", "Полный текст"])
        if self.check_info == [1, 1, 1]:
            self.out.tableWidget.setHorizontalHeaderLabels(["Ссылка", "Ключевые слова", "Биграммы", "Резюме", "Полный текст"])

        self.table = []  # Список хранения собранных данных для Excel (pandas)

        # Создание отдельного потока для отображение прогреса (Прогрессбар, Информация о процессе)
        self.obj = Worker(self.parselist, self.check_info, self.progressinfo, self.out, self.table)
        self.thread = QThread()
        self.obj.intReady.connect(self.on_count_changed)
        self.obj.moveToThread(self.thread)
        self.obj.finished.connect(self.thread.quit)
        self.thread.started.connect(self.obj.proc_counter)
        self.thread.start()
        self.thread.finished.connect(lambda: self.show_outwindow(self.out))  # При окончании вызов окна вывода

        self.pushButton_2.clicked.connect(self.announcement)

        self.out.pushButton_2.clicked.connect(self.show_table)

    def on_count_changed(self, value):  # Изменение значения прогрессбара
        self.progressBar.setValue(value)

    def announcement(self):  # Вызов окна предупреждения
        self.ann = WarningWindow()
        self.ann.show()

    def show_outwindow(self, out):  # Вызов окна вывода
        out.show()
        self.setVisible(False)

    def show_table(self):  # Сохранение собранной информации в Excel
        os.chdir('Результаты анализа')
        name_forder = (str(datetime.datetime.now().strftime("%d-%m-%Y %H:%M")).replace(':', '_'))

        if not os.path.isdir(name_forder):
            os.mkdir(name_forder)

        os.chdir(name_forder)
        f = os.getcwd()

        for line in self.table:
            if line[0].startswith('https://'):
                file_name_to_text = f + '\\' + line[0].replace('https://', '').replace('/', '_').replace('.', '_') + '.txt'
                open(file_name_to_text, 'w', encoding='utf8').write(line[-1])
                line[-1] = file_name_to_text
            else:
                self.table.pop(line)

        df = pd.DataFrame(self.table)
        if self.check_info == [0, 0, 0]:
            df.rename(columns={0: 'Ссылка', 1: 'Путь до файла с текстом'}, inplace=True)
        if self.check_info == [1, 0, 0]:
            df.rename(columns={0: 'Ссылка', 1: 'Ключевые слова', 2: 'Путь до файла с текстом'}, inplace=True)
        if self.check_info == [0, 1, 0]:
            df.rename(columns={0: 'Ссылка', 1: 'Биграммы', 2: 'Путь до файла с текстом'}, inplace=True)
        if self.check_info == [0, 0, 1]:
            df.rename(columns={0: 'Ссылка', 1: 'Резюме', 2: 'Путь до файла с текстом'}, inplace=True)
        if self.check_info == [1, 1, 0]:
            df.rename(columns={0: 'Ссылка', 1: 'Ключевые слова', 2: 'Биграммы', 3: 'Путь до файла с текстом'}, inplace=True)
        if self.check_info == [1, 0, 1]:
            df.rename(columns={0: 'Ссылка', 1: 'Ключевые слова', 2: 'Резюме', 3: 'Путь до файла с текстом'}, inplace=True)
        if self.check_info == [0, 1, 1]:
            df.rename(columns={0: 'Ссылка', 1: 'Биграммы', 2: 'Резюме', 3: 'Путь до файла с текстом'}, inplace=True)
        if self.check_info == [1, 1, 1]:
            df.rename(columns={0: 'Ссылка', 1: 'Ключевые слова', 2: 'Биграммы', 3: 'Резюме', 4: 'Путь до файла с текстом'}, inplace=True)
        writer = pd.ExcelWriter('output.xlsx')
        df.to_excel(writer)
        writer.save()


# Второй поток для окна прогресса
class Worker(QObject):
    finished = pyqtSignal()
    intReady = pyqtSignal(int)

    def __init__(self, parselist, check_info, progressinfo, out, table, parent=None):
        super(Worker, self).__init__(parent)
        self.parselist = parselist
        self.check_info = check_info
        self.progressinfo = progressinfo
        self.out = out
        self.table = table




    @pyqtSlot()
    def proc_counter(self):
        count_progress = 0
        count_vertical = 0
        count_horizontal = 0
        line_list = []
        error = 0


        for links in self.parselist:  # цикл прохождения по каждой ссылке
            if links.startswith('https://'):
                self.out.tableWidget.setItem(count_vertical, count_horizontal, QtWidgets.QTableWidgetItem(links))
                self.out.tableWidget.item(count_vertical, count_horizontal).setTextAlignment(0x0020)
                line_list.append(links)
                count_horizontal += 1
                if links.startswith('https://'):
                    self.progressinfo.setText(links + ":  Получение текста")
                    text = access(links, 0)  # Получение текста
                    if text[2] != 200 or text[0].startswith('No right proxcies'):
                        print('Невозможно зайти на сайт')
                        error = 1
                    count_progress += 1
                    self.intReady.emit(count_progress)
                    l = lemma(text[1].split())  # Получение леммы
                    self.progressinfo.setText(links + ":  Создание леммы")
                    count_progress += 1
                    self.intReady.emit(count_progress)
                    if self.check_info[0] == 1:
                        self.progressinfo.setText(links + ":  Получение ключевых слов")
                        keywords = ohten_words(l)  # Получение ключевых слов
                        self.out.tableWidget.setItem(count_vertical, count_horizontal, QtWidgets.QTableWidgetItem(keywords))
                        self.out.tableWidget.item(count_vertical, count_horizontal).setTextAlignment(0x0020)
                        line_list.append(keywords)
                        count_horizontal += 1
                        count_progress += 1
                        self.intReady.emit(count_progress)
                    if self.check_info[1] == 1:
                        self.progressinfo.setText(links + ":  Получение биграмм")
                        bigram = digrams(l)  # Получение бирамм
                        self.out.tableWidget.setItem(count_vertical, count_horizontal, QtWidgets.QTableWidgetItem(bigram))
                        self.out.tableWidget.item(count_vertical, count_horizontal).setTextAlignment(0x0020)
                        line_list.append(bigram)
                        count_horizontal += 1
                        count_progress += 1
                        self.intReady.emit(count_progress)
                    if self.check_info[2] == 1:
                        resume = anotation(text[1], l)
                        self.out.tableWidget.setItem(count_vertical, count_horizontal, QtWidgets.QTableWidgetItem(resume))
                        self.out.tableWidget.item(count_vertical, count_horizontal).setTextAlignment(0x0020)
                        line_list.append(resume)  # Получение резюме (Анотации)
                        count_horizontal += 1
                        self.progressinfo.setText(links + ":  Создание резюме")
                        count_progress += 1
                        self.intReady.emit(count_progress)
                else:
                    count_progress += 2
                    self.intReady.emit(count_progress)
                    if self.check_info[0] == 1:
                        count_progress += 1
                        self.intReady.emit(count_progress)
                    if self.check_info[1] == 1:
                        count_progress += 1
                        self.intReady.emit(count_progress)
                    if self.check_info[2] == 1:
                        count_progress += 1
                        self.intReady.emit(count_progress)
                if error == 0:
                    self.out.tableWidget.setItem(count_vertical, count_horizontal, QtWidgets.QTableWidgetItem(text[1]))
                    line_list.append(text[1])
                else:
                    self.out.tableWidget.setItem(count_vertical, count_horizontal, QtWidgets.QTableWidgetItem('Невозможно зайти на сайт'))
                    line_list.append('Невозможно зайти на сайт')
                self.out.tableWidget.item(count_vertical, count_horizontal).setTextAlignment(0x0020)
                self.table.append(line_list.copy())
                line_list.clear()
                error = 0
                count_horizontal = 0
                count_vertical += 1

        self.finished.emit()


# Обьявление окна с предепреждением о выходе
class WarningWindow(QtWidgets.QMainWindow, Ui_WarningWindow):  # +++
    def __init__(self, parent=None):
        super(WarningWindow, self).__init__(parent)

        self.setupUi(self)
        self.pushButton.clicked.connect(self.stop)
        self.pushButton_2.clicked.connect(self.cancel)

    def stop(self):
        import sys
        sys.exit(0)

    def cancel(self):
        self.setVisible(False)


# Обьявление окна вывода
class OutWindow(QtWidgets.QMainWindow, Ui_OutWindow):  # +++
    def __init__(self, parent=None):
        super(OutWindow, self).__init__(parent)

        self.setupUi(self)


# Запуск программы
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    ex = Parsing()
    ex.show()
    sys.exit(app.exec_())









